<!DOCTYPE html> 
<html lang="en">
<head>
    <title>Escena 3D:Vampiro</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - FBXLoader<br />
        Character and animation from <a href="https://www.mixamo.com/" target="_blank" rel="noopener">Mixamo</a>
    </div>
 
<footer style="
    position: absolute;
    top: 10px;       /* desde arriba */
    left: 50%;
    transform: translateX(-50%);
    font-family: Arial, sans-serif;
    font-weight: bold;
    color: #dfe6ee;  /* gris claro para contrastar con la escena */
    text-align: center;
    pointer-events: none; /* deja pasar clics a la escena */
    z-index: 10;
">
    <h1></h1>
    <p>Integrantes del equipo: Medina Sanchez Abdul Kalid, Maya Alejandro Angel Valerde</p>
    <p>Números de control: 23200865</p>
    <p>Controles:</p>
    <ul style="list-style:none; padding:0; margin:0;">
        <li>W / ↑ : Avanzar</li>
        <li>S / ↓ : Retroceder</li>
        <li>A / ← : Mover izquierda</li>
        <li>D / → : Mover derecha</li>
        <li>Shift : Correr</li>
        <li>Espacio : Saltar</li>
    </ul>
</footer>


    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>
     <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
import Stats from 'three/addons/libs/stats.module.js';

const MODEL_PATH ='models/fbx/Vampire A Lusth.fbx'; // <- pon aquí tu fbx (con animaciones)
const HDR_PATH = 'models/rgbe/rogland_clear_night_4k.hdr';

let camera, scene, renderer, stats, controls;
let mixer, model, currentAction, actions = {};
const clock = new THREE.Clock();
let velocity = new THREE.Vector3(); // para movimiento del personaje
const speed = 5;
const runSpeed = 9;
const jumpSpeed = 180;
let onGround = true;

// Controles del juego
const keyState = {};
const animationNames = [
    'Shooting',
    'Jumping',
    'Idle',
    'Drunk Walk',
    'Zombie Walk'
];
let activeAnimIndex = 0;

// Objetos dinámicos (física sencilla)
const dynamicObjects = [];
const GRAVITY = -20000;
const FLOOR_Y = 0;

// Bounding helpers
const charBox = new THREE.Box3();

// Inicializar
init();
animate();

function init() {
    // contenedor
    const container = document.createElement('div');
    document.body.appendChild(container);

    // cámara
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(0, 5, 12);

    // escena
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x20242a);
 scene.fog = new THREE.Fog(0xdfe6ee, 5, 80); // niebla más densa y cercana


    // renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // controls (mouse)
    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,1.5,0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    // stats
    stats = new Stats();
    container.appendChild(stats.dom);

    // Iluminación: sol (directional), luna/point, ambiente (hemisphere)
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.6);
    sun.position.set(50, 80, 20);
    sun.castShadow = true;
    sun.shadow.camera.left = -50;
    sun.shadow.camera.right = 50;
    sun.shadow.camera.top = 50;
    sun.shadow.camera.bottom = -50;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    const lamp = new THREE.PointLight(0xffeaa7, 0.8, 50);
    lamp.position.set(-6, 6, -6);
    lamp.castShadow = true;
    scene.add(lamp);

    // HDR environment (si falla, la escena seguirá con color/iluminación)
    const rgbe = new RGBELoader();
    rgbe.load(HDR_PATH, (tex) => {
        tex.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = tex;
        // no forzamos background porque ya tenemos fog + color
    }, undefined, (err) => {
        console.warn('HDR no cargado:', err);
    });


    // --- Audio de fondo ---
const listener = new THREE.AudioListener();
camera.add(listener);

const sound = new THREE.Audio(listener);

const audioLoader = new THREE.AudioLoader();
audioLoader.load('Sound/Theme_Laura.mp3', function(buffer) {
    sound.setBuffer(buffer);
    sound.setLoop(true);      // Repetir canción
    sound.setVolume(0.4);     // Volumen (0.0 a 1.0)
    sound.play();
});


    // PISO procedimental con textura "ajedrez" via canvas para no requerir archivos
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // Muros altos alrededor del personaje (mucho espacio para moverse)
const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
const wallHeight = 6; // altura de los muros
const wallThickness = 1; // grosor de los muros
const wallDistance = 30; // distancia del centro del escenario

const boundaryWalls = [];

// Pared trasera
const wallBack = new THREE.Mesh(new THREE.BoxGeometry(wallDistance * 2, wallHeight, wallThickness), wallMaterial);
wallBack.position.set(0, wallHeight/2, -wallDistance);
scene.add(wallBack);
boundaryWalls.push({ mesh: wallBack, velocity: new THREE.Vector3(0,0,0), groundOffset: wallHeight/2 });

// Pared frontal
const wallFront = new THREE.Mesh(new THREE.BoxGeometry(wallDistance * 2, wallHeight, wallThickness), wallMaterial);
wallFront.position.set(0, wallHeight/2, wallDistance);
scene.add(wallFront);
boundaryWalls.push({ mesh: wallFront, velocity: new THREE.Vector3(0,0,0), groundOffset: wallHeight/2 });

// Pared izquierda
const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, wallDistance * 2), wallMaterial);
wallLeft.position.set(-wallDistance, wallHeight/2, 0);
scene.add(wallLeft);
boundaryWalls.push({ mesh: wallLeft, velocity: new THREE.Vector3(0,0,0), groundOffset: wallHeight/2 });

// Pared derecha
const wallRight = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, wallDistance * 2), wallMaterial);
wallRight.position.set(wallDistance, wallHeight/2, 0);
scene.add(wallRight);
boundaryWalls.push({ mesh: wallRight, velocity: new THREE.Vector3(0,0,0), groundOffset: wallHeight/2 });

    


    // dibujar patrón cuadricula simple
    ctx.fillStyle = '#cfe7ff'; ctx.fillRect(0,0,512,512);
    ctx.fillStyle = '#e8f2ff';
    for (let y=0; y<8; y++) {
        for (let x=0; x<8; x++) {
            if ((x+y)%2===0) ctx.fillRect(x*64,y*64,64,64);
        }
    }
    const floorTex = new THREE.CanvasTexture(canvas);
    floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
    floorTex.repeat.set(20,20);

    const floorMat = new THREE.MeshPhysicalMaterial({
        map: floorTex,
        metalness: 0.2,
        roughness: 0.6
    });
    const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(200,200), floorMat);
    floorMesh.rotation.x = - Math.PI/2;
    floorMesh.receiveShadow = true;
    floorMesh.position.y = FLOOR_Y;
    scene.add(floorMesh);

// Cargar modelo principal
const loader = new FBXLoader();
loader.load(MODEL_PATH, (fbx) => {
    model = fbx;
    model.scale.setScalar(0.02);
    model.position.set(0, FLOOR_Y, -7); // antes era 0,0,0
    model.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });

    mixer = new THREE.AnimationMixer(model);
    scene.add(model);

    // Primero cargamos las animaciones adicionales
    const animLoader = new FBXLoader();
    const animPromises = animationNames.map(name => {
        return new Promise((resolve, reject) => {
            animLoader.load(`models/fbx/${name}.fbx`, anim => {
                const clip = anim.animations[0];
                if (clip) {
                    const action = mixer.clipAction(clip);
                    actions[name] = action;
                    resolve();
                } else resolve(); // sin animación válida
            }, undefined, reject);
        });
    });

    Promise.all(animPromises).then(() => {
        // Establecer animación inicial
        if (actions['Idle']) {
            playAction('Idle');
        } else if (Object.keys(actions).length > 0) {
            playAction(Object.keys(actions)[0]);
        }
    }).catch(err => console.error('Error cargando animaciones:', err));

}, undefined, (err) => console.error('Error cargando modelo:', err));


    // Agregar 5 objetos dinámicos con física simple (cajas y esferas)
    addDynamicObjects();

    // Eventos teclado & mouse
    window.addEventListener('keydown', (e)=>{ keyState[e.code]=true; handleKeyDown(e); });
    window.addEventListener('keyup', (e)=>{ keyState[e.code]=false; });
    window.addEventListener('resize', onWindowResize);

    // GUI simple para debug (opcional)
    const gui = new GUI();
    gui.add({anim: animationNames[0]}, 'anim').name('Anim example');
    gui.add({reset: ()=>{ resetScene(); }}, 'reset').name('Reset scene');
    // fin init
}

// Cambiar y reproducir animación con crossfade
function playAction(name) {
    if (!actions[name]) return;
    const toPlay = actions[name];
    toPlay.reset();
    toPlay.play();
    if (currentAction && currentAction !== toPlay) {
        // crossfade
        toPlay.crossFadeFrom(currentAction, 2.0, true);
    }
    currentAction = toPlay;
}

// Manejo de teclas para movimiento, jump y cambios de animación
function handleKeyDown(e) {
    // Cambiar animación con teclas numéricas 1..5
    if (e.code.startsWith('Digit')) {
        const idx = parseInt(e.code.replace('Digit','')) - 1;
        if (idx >= 0 && idx < animationNames.length) {
            activeAnimIndex = idx;
            playAction(animationNames[idx]);
        }
    }
    // Espacio para salto
    if (e.code === 'Space' && onGround) {
        velocity.y = jumpSpeed;
        onGround = false;
        if (actions['Jump']) playAction('Jump');
    }
    // Acciones adicionales: tecla F para disparo (si existe)
    if (e.code === 'KeyF') {
        if (actions['Shoot']) playAction('Shoot');
    }
}

// Animación principal
function animate() {
    requestAnimationFrame( animate );
    const dt = Math.min(0.05, clock.getDelta());

    // actualizar mixer (animaciones)
    if (mixer) mixer.update(dt);

    // Mover personaje según WASD con giro suave y movimiento natural
if (model) {
    const dt = clock.getDelta();

    // Obtener direcciones base
    const forward = new THREE.Vector3();
    model.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();

    const right = new THREE.Vector3();
    right.crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();

    // Movimiento según teclas
    let move = new THREE.Vector3();
    const walking = keyState['KeyW'] || keyState['ArrowUp'];
    const back = keyState['KeyS'] || keyState['ArrowDown'];
    const left = keyState['KeyA'] || keyState['ArrowLeft'];
    const rightk = keyState['KeyD'] || keyState['ArrowRight'];
    const running = keyState['ShiftLeft'] || keyState['ShiftRight'];

    if (walking) move.add(forward);
    if (back) move.sub(forward);
    if (left) move.sub(right);
    if (rightk) move.add(right);

    // Si hay movimiento
    if (move.lengthSq() > 0.001) {
        move.normalize();
        // Velocidad base
let sp = running ? runSpeed : speed;

// Si se mueve hacia adelante (sin ir en diagonal), aumenta la velocidad
if (walking && !back && !left && !rightk) {
    sp *= 50.5; // ← Aumenta este factor si quieres aún más velocidad (1.8 o 2)
}


        // Calcular ángulo objetivo y rotar suavemente
        const targetAngle = Math.atan2(move.x, move.z);
        const currentY = model.rotation.y;
        let deltaAngle = targetAngle - currentY;
        deltaAngle = Math.atan2(Math.sin(deltaAngle), Math.cos(deltaAngle));
        const turnSpeed = 30; // <— ajusta de 4 a 10 según preferencia
        model.rotation.y += deltaAngle * turnSpeed * dt;

        // Calcular la dirección hacia donde está mirando
        const facing = new THREE.Vector3(
            Math.sin(model.rotation.y),
            0,
            Math.cos(model.rotation.y)
        );

        // Desplazar suavemente hacia adelante (en dirección actual)
        model.position.addScaledVector(facing, sp * dt);

        // Elegir animación
        if (running && actions['Run']) playAction('Run');
        else if (actions['Walk']) playAction('Walk');
    } else {
        if (!keyState['Space'] && actions['Idle']) playAction('Idle');
    }

    // Gravedad simple
    velocity.y += GRAVITY * dt;
    model.position.y += velocity.y * dt;
    if (model.position.y <= FLOOR_Y) {
        model.position.y = FLOOR_Y;
        velocity.y = 0;
        onGround = true;
    }

    // Actualizar caja de colisión del personaje
    const box = new THREE.Box3().setFromObject(model);
    charBox.copy(box);
          
        // verificar colisión con objetos dinámicos
        for (let obj of dynamicObjects) {
            // AABB simple
            const objBox = new THREE.Box3().setFromObject(obj.mesh);
            if (charBox.intersectsBox(objBox)) {
                // resolución simple: empujar el personaje hacia atrás según vector entre centros
                const charCenter = charBox.getCenter(new THREE.Vector3());
                const objCenter = objBox.getCenter(new THREE.Vector3());
                const push = charCenter.clone().sub(objCenter).setY(0).normalize().multiplyScalar(0.15);
                model.position.add(push);
                // aplicar impulso al objeto
                obj.velocity.add(push.multiplyScalar(8));
            }
        }
    }

    // actualizar física de objetos dinámicos
    for (let obj of dynamicObjects) {
        // gravedad
        obj.velocity.y += GRAVITY * dt;
        obj.mesh.position.addScaledVector(obj.velocity, dt);

        // colisión con piso
        if (obj.mesh.position.y <= FLOOR_Y + obj.groundOffset) {
            obj.mesh.position.y = FLOOR_Y + obj.groundOffset;
            obj.velocity.y *= -0.25; // rebote amortiguado
            // fricción suelo
            obj.velocity.x *= 0.8;
            obj.velocity.z *= 0.8;
            if (Math.abs(obj.velocity.y) < 0.1) obj.velocity.y = 0;
        }

        // límites para mantener en escena
        const limit = 95;
        obj.mesh.position.x = THREE.MathUtils.clamp(obj.mesh.position.x, -limit, limit);
        obj.mesh.position.z = THREE.MathUtils.clamp(obj.mesh.position.z, -limit, limit);
    }

    // mover cámara con teclas I J K L / z x para zoom
    if (keyState['KeyI']) camera.position.z -= 8 * dt;
    if (keyState['KeyK']) camera.position.z += 8 * dt;
    if (keyState['KeyJ']) camera.position.x -= 8 * dt;
    if (keyState['KeyL']) camera.position.x += 8 * dt;
    if (keyState['KeyZ']) camera.position.y += 8 * dt;
    if (keyState['KeyX']) camera.position.y -= 8 * dt;

    controls.update();
    renderer.render(scene, camera);
    stats.update();
}

// Función para añadir objetos dinámicos (piedras, caja, arma, etc.)
function addDynamicObjects() {
    // cada objeto tiene: mesh, velocity, mass, groundOffset
    const matRock = new THREE.MeshStandardMaterial({ color: 0x8b8b8b, roughness: 0.7, metalness: 0.1 });
    const matWood = new THREE.MeshStandardMaterial({ color: 0x7a5230, roughness: 0.8, metalness: 0.05 });
    const matMetal = new THREE.MeshStandardMaterial({ color: 0xb0c4de, roughness: 0.25, metalness: 0.9 });

    // Piedra 1 (esfera)
    const s1 = new THREE.Mesh(new THREE.SphereGeometry(1.3, 16, 16), matRock);
    s1.castShadow = true;
    s1.position.set(6, 2, -3);
    scene.add(s1);
    dynamicObjects.push({ mesh: s1, velocity: new THREE.Vector3(0,0,0), groundOffset: 1.3 });

    // Piedra 2 (box irregular)
    const b1 = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.6,1.6), matRock);
    b1.castShadow = true;
    b1.position.set(-4, 1.6, 4);
    scene.add(b1);
    dynamicObjects.push({ mesh: b1, velocity: new THREE.Vector3(0,0,0), groundOffset: 0.8 });

    // Mueble (caja grande)
    const chest = new THREE.Mesh(new THREE.BoxGeometry(2.5,1.5,1.2), matWood);
    chest.castShadow = true;
    chest.position.set(3, 0.75, 6);
    scene.add(chest);
    dynamicObjects.push({ mesh: chest, velocity: new THREE.Vector3(0,0,0), groundOffset: 0.75 });

    // Arma (torus + handle) — representativo
    const tor = new THREE.Mesh(new THREE.TorusGeometry(0.7,0.2,12,30), matMetal);
    tor.castShadow = true;
    tor.position.set(-8, 0.9, -6);
    tor.rotation.x = Math.PI/2;
    scene.add(tor);
    dynamicObjects.push({ mesh: tor, velocity: new THREE.Vector3(0,0,0), groundOffset: 0.9 });

    // Pilar / muro pequeño
    const wall = new THREE.Mesh(new THREE.BoxGeometry(0.6,3.5,2.0), new THREE.MeshStandardMaterial({ color:0x999999, roughness:0.9 }));
    wall.position.set(10, 1.75, 2);
    wall.castShadow = true;
    scene.add(wall);
    dynamicObjects.push({ mesh: wall, velocity: new THREE.Vector3(0,0,0), groundOffset: 1.75 });

    // opcional: empujar objetos si hay animación de impacto (aquí no)
}

// reset rápido (debug)
function resetScene() {
    // posicion personaje
    if (model) {
        model.position.set(0,FLOOR_Y,0);
        model.rotation.set(0,0,0);
        velocity.set(0,0,0);
    }
    // reset objetos
    let p = [[6,2,-3],[-4,1.6,4],[3,0.75,6],[-8,0.9,-6],[10,1.75,2]];
    for (let i=0;i<dynamicObjects.length;i++){
        dynamicObjects[i].mesh.position.set(p[i][0],p[i][1],p[i][2]);
        dynamicObjects[i].velocity.set(0,0,0);
    }
}

// resize
function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
